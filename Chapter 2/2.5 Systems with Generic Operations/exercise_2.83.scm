(load "Chapter 2/2.5 Systems with Generic Operations/generic_arithmetic.scm")

(define (install-real-package)
  (define (tag x)
    (attach-tag 'real x))    
  (put 'add '(real real)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(real real)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(real real)
       (lambda (x y) (tag (* x y))))
  (put 'div '(real real)
       (lambda (x y) (tag (/ x y))))
  (put 'equ? '(real real) =)
  (put '=zero? '(real)
       (lambda (x) (= 0 x)))
  (put 'make 'real
       (lambda (x) (if (real? x)
                       (tag x)
                       (error "non-real value" x))))
  'done )

(install-real-package)
(define (make-real n)
    ((get 'make 'real) n))

(define (scheme-number->rational scheme-number)
    (make-rational (cdr scheme-number) 1))
(define (rational->real rational)
    (define (integer->floating-point integer) 
        (* integer 1.0)) 
    (define (numer rational) (cadr rational))
    (define (denom rational) (cddr rational))
    (make-real (/ (integer->floating-point (numer rational)) 
                  (denom rational))))
(define (real->complex real)
    (make-complex-from-real-imag (cdr real) 0))

(put-coercion 'scheme-number 'rational scheme-number->rational)
(put-coercion 'rational 'real rational->real)
(put-coercion 'real 'complex real->complex)

(define (raise n)
    (define hierarchy '(scheme-number rational real complex))
    (define (raise-iter number tower)
        (if (null? tower)
            (error "No method for these types: RAISE" (type-tag number))
            (if (eq? (type-tag number) (car tower))
                ((get-coercion (car tower) (cadr tower)) n)
                (raise-iter number (cdr tower)))))
    (raise-iter n hierarchy))