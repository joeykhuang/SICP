(load "Chapter 2/2.5 Systems with Generic Operations/exercise_2.83.scm")
; # TODO: Add support for multiple arguments
(define (apply-generic op . args)
    (define hierarchy '(complex real rational scheme-number))
    (define (higher-in-tower type1 type2 tower)
        (cond ((null? tower) (error "Type not in tower" (cons type1 type2)))
              ((eq? type1 (car tower)) type1)
              ((eq? type2 (car tower)) type2)
              (else (higher-in-tower type1 type2 (cdr tower)))))
    (define (raise-to a type)
        (if (eq? (type-tag a) type)
            a
            (raise-to (raise a) type)))
    (let ((type-tags (map type-tag args)))
        (let ((proc (get op type-tags)))
            (if proc
                (apply proc (map contents args))
                (if (and (= (length args) 2)
                         (not (eq? (car type-tags) 
                                   (cadr type-tags))))
                    (let ((type1 (car type-tags))
                          (type2 (cadr type-tags))
                          (a1 (car args))
                          (a2 (cadr args)))
                        (let ((coerce-to (higher-in-tower type1 type2 hierarchy)))
                            (cond ((eq? type1 coerce-to)
                                    (apply-generic op a1 (raise-to a2 coerce-to)))
                                  ((eq? type2 coerce-to)
                                    (apply-generic op (raise-to a1 coerce-to) a2))
                                (else (error "No method for these types"
                                            (list op type-tags))))))
                    (error "No method for these types"
                           (list op type-tags)))))))